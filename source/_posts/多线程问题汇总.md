---
title: 多线程问题汇总
categories: java进阶之路
date: 2021-06-28 23:17:46
tags:
  - java 
  - 面试

---

## 多线程问题汇总

### 谈谈你对volatile的理解

- valatile是java虚拟机提供的轻量级的同步机制
  - 保证可见性
    - 假如int num = 0；num 变量之前没有添加volatile关键字修饰，没有可见性。工作内存中修改，主内存值不变。
    - 添加了volatile，可解决可见性问题
  - 不保证原子性(i++)
    - 如何解决？
      - 加sync
      - AtomicInteger.getAndIncrement()
  - 禁止指令重排
- 谈谈JMM
  - 由于JVM运行程序的实体是内存，而每个线程创建时JVM都会为其创建一个工作内存，工作内存时每个线程的私有数据区域，而java内存模型中规定所有变量都存储在主内存。
  - 主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存空间，然后再对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存的变量。
  - 各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成
- 在什么地方用到过valatile
  - 单例模式：防止指令重排
    - 分配对象内存空间
    - 初始化对象
    - 设置instance指向内存分配的内存地址

### CAS你知道吗？

- 需要取出内存中某时刻的数据并在当下时刻比较并交换 

- CAS底层原理？谈谈UnSafe的理解  

- CAS缺点

  - 循环时间长开销很大

    - ```java
      public final int getAndAddInt(Object var1,long var2,int var4){
          int var5;
          do{
              var5 = 	this.getIntVolatile(var1,var2);
          }while(!this.compareAndSwapInt(var1,var2,var5,var5+var4));
          return var5;
      }
      ```

  - 只能保证一个共享变量的原子操作

    - 对于多个变量原子操作只能通过加锁来保证

  - ABA问题

    - AtomicReference的使用，使得对象可以解决aba问题
    - AtomicStampReference的使用，使得可以进行版本之间叠加
    - 解决方法：新增一种机制，就是修改版本号（类似时间戳）

### ArrayList：高并发下add操作

- 故障现象
  - java.util.ConcurrentModificationException
- 导致原因
  - 并发争抢修改导致
  - 一个正在写入，另外一个过来抢夺，导致数据不一致异常，导致修改异常
- 解决方案
  - new Vector<>()
  - Collections.synchronizedList(new ArrayList<>());
  - new CopyOnWriteArrayList<>();复制并写入集合
- 优化建议（同样的错误不犯第2次 ）

### Set：底层是HashMap

- 故障现象
  - java.util.ConcurrentModificationException
- 解决方案
  - Collections.synchronizedSet(new HashSet<>());
  - new CopyOnWriteArraySet<>();复制并写入集合

### HashMap

- ConcurrentHashMap

### 公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解？请手写一个自旋锁

- 公平和非公平锁
  - 公平锁：是多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到，ReentrantLock(true)
  - 非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象，ReentrantLock()，Synchronized
- 可重入锁（递归锁）
  - 指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
  - 也即使说，线程可以进入任何一个它已经拥有的锁所同步着的代码块
  - ReentrantLock()，Synchronized，lock
  - 作用：避免死锁，用的是同一把锁
- 自旋锁
  -  是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试获取锁
  - 好处是减少线程上下文切换的消耗，缺点是循环会消耗cpu
- 独占锁（写锁）/共享锁（读锁）/互斥锁
  - 独占锁：该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁
  - 共享锁：该锁可以被多个线程所持有，对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁。
  - 读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

### CountDownLatch/CyclicBarrier/Semaphon使用过吗？

- CountDownLatch
  - 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒
  - CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞，其他线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值变为0时，因调用await方法被阻塞的线程会被唤醒，继续执行。
- CyclicBarrier
  - CyclicBarrier的字面意思是可循环(Cyclic)使用的屏障(Barrier)。它要做的事情是，让一组线程到达一个屏障(也可叫同步点)时被阻塞，知道最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。
- Semaphone
  - 信号量主要用于两个目的，一个用于多个共享资源的互斥使用，另一个用于并发线程数的控制。

### 阻塞队列知道吗？

- 队列+阻塞队列
  - 阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列，线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素
  - 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。当阻塞队列是满时，往队列里添加元素的操作将会被阻塞
- 为什么用？有什么好处？
  -  在多线程领域：所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤醒
  - 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了
- BlockingQueue的核心方法
- 架构梳理+种类分析
  - (重要)ArrayBlockQueue：由数组组成的有界阻塞队列
  - (重要)LinkedBlockQueue：由链表构成的有界(但大小默认值为Integer.MAX_VALUE)阻塞队列
  - PriorityBlockQueue:支持优先级排序的无界阻塞队列
  - DelayQueue:使用优先级队列实现的延迟无界阻塞队列
  - (重要)SynchronousQueue:不存储元素的阻塞队列，也即单个元素的队列，同步阻塞队列
    - SynchronousQueue没有容量。每一个put操作必须等待一个take操作，否则不能继续添加元素，反之亦然
  - LinkedTransferQueue：由链表结构组成的无界阻塞队列
  - LinkedBlockingDeque：由链表结构组成的双向阻塞队列
- 用在哪里
  - 生产者消费者模式
    - 传统版：ProdConsumer_Traditon
    - 阻塞队列版：ProdConsumer_BlockQueue
  - 线程池
  - 消息中间件

### synchronized和lock有什么区别？用新的lock有什么好处，你举例说说

- 原始构成
  - synchronized是关键字属于JVM层面
  - lock是具体类(java.util.concurrent.locks.lock)是api层面
- 使用方法
  - synchronized不需要用户手动释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用
  - ReentrantLock需要用户手动去释放锁，若没有主动释放，则会出现死锁现象，需要lock()和unlock()方法配合try/finallly语句块来完成。
- 等待是否可中断
  - synchronized不可中断，除非抛出异常或者正常运行完成
  - ReentrantLock可中断
    - 设置超时方法tryLock(long timeout,TimeUnit unit)
    - lockInterruptibly()放代码块中，调用interrupt()方法可中断
- 加锁是否公平
  - synchronized是非公平锁
  - ReentrantLock两者都可以，默认公平锁。构造方法可以传入boolean值，true为公平锁，false为非公平锁。
- 锁绑定多个条件condition
  - synchronized没有
  - reentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程

### 线程池用过吗？ThreadPollExecutor谈谈你的理解

- 为什么用线程池，优势
  - 线程池做的工作主要是控制运行线程的数量。处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超过数量的线程排队等待，等其他线程执行完毕，再从队列中取出任务来执行。
  - 主要特点
    - 线程复用
    - 控制最大并发数
    - 管理线程
  - 优点
    - 降低资源消耗，通过重复利用已创建的线程减低线程创建和销毁造成的消耗
    - 提高相应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行
    - 提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
- 线程池如何使用？
  - ThreadPoolExecutor
    - Executors.newFixedThreadPool(int)，执行长期的任务，性能好很多
    - Executors.newFixedThreadPool(int)，一个任务一个任务执行的场景
    - Executors.newCachedThreadPool()，执行很多短期异步的小程序或者负载较轻的服务
- 线程池的几个重要参数介绍？
  - corePoolSize:线程池中的常驻核心线程数
  - maxmumpoolSize:线程池能够容纳同时执行的最大线程数，此值必须大于等于1。等待队列满了后，再有新的请求过来，会进行扩容到最大线程数。
  - keepAliveTime:多余的空闲线程的存活时间。。当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。
  - unit:keepAliveTime的单位
  - workQueue:任务队列，被提交但尚未被执行的任务
  - threadFactory:表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可。
  - handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maxmumPoolSize）时如何拒绝请求执行来的runnable的策略。
- 说说线程池的底层工作原理？
  - 在创建了线程池后，等待提交过来的任务请求
  - 当调用execute()方法添加一个请求任务时，线程池会做如下判断：
    - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
    - 如果正在运行的线程数量大于或者等于corePoolSize，那么将这个任务放入队列
    - 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务。
    - 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。
  - 当一个线程完成任务时，它会从队列中取出下一个任务来执行。
  - 当一个线程无事可做超过一定的时间(KeepAliveTime)时，线程池会判断：
    - 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。
    - 所有线程池任务完成后最终会收缩到corePoolSize的大小。

### 线程池用过吗？生产上你如何设置合理参数

- 线程池的拒绝策略你谈谈
  - AbortPolicy(默认)：直接抛出RejectedExecutionException异常组织系统正常运行。
  - CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
  - DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。
  - DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案。
  - 以上拒绝策略均实现了RejectedExecutionHandler接口。
- 你在工作中单一的/固定数的/可变的三种创建线程池的方法，你用哪个多？
  - 一个都不用，我们生产上只能使用自定义的
  - Executors中JDK已经给你提供了，为什么不用？
    - 因为阿里规范，队列为Linked，是一个无界队列。
- 你在工作中是如何使用线程池的，是否自定义过线程池使用
- 合理配置线程池你是如何考虑的？
  - CPU密集型
    - CPU密集的意思是该任务需要大量的运算，而没有阻塞，cpu一直全速运行。一般公式：CPU核数+1个线程的线程池
  - IO密集型
    - 由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2
    - IO密集型，即该任务需要大量的IO，即大量的阻塞。参考公式：CPU核数/1-阻塞系数。阻塞系数：0.8-0.9之间

### 死锁编码及定位分析

- 是什么
  - 死锁是指两个或者两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉，那他们都将无法推进下去。
  - 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因为争夺有限资源而陷入死锁
  
- 代码

  - ```java
    public void run() {
            synchronized (lockA) {
                System.out.println(Thread.currentThread().getName() + "\t,自己持有：" + lockA +"\t,尝试获取锁：" + lockB);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lockB) {
                    System.out.println(Thread.currentThread().getName() + "\t,自己持有：" + lockB +"\t,尝试获取锁：" + lockA);
                }
            }
        }
    ```

- 主要原因
  - 系统资源不足
  - 进程运行推进的顺序不合适
  - 资源分配不当
  
- 解决
  - jps -l命令定位进程号
  - jstack 进程号。找到死锁查看
